---
sidebar_position:	2
title:				std::unordered_set reference
sidebar_label:		unordered_set
tags:				[unordered_set, set, unordered, associative, container, key]
hide_title:			true
---

import ClassSummary				from "@site-comps/ClassSummary";
import SymbolTable, { Symbol }	from "@site-comps/SymbolTable";
import SwitchView 		from "@site-comps/SwitchView"
import Columns					from "@site-comps/Columns";
import NotFinished				from "@site/i18n/en/presets/NotFinished.mdx";
import ImproveSection			from "@site/i18n/en/presets/ImproveSection.mdx";
import Tabs						from "@theme/Tabs";
import TabItem					from "@theme/TabItem";

<!-- Top Examples -->
import CodeSimplifiedRegular from "./_codes/unordered-set/main-page/overview-simplified-regular.mdx";
import CodeDetailedReguler from "./_codes/unordered-set/main-page/overview-detailed-regular.mdx";
import CodeDetailedPmr from "./_codes/unordered-set/main-page/overview-detailed-pmr.mdx";

import TopExampleCreateCpp17 from "./_codes/unordered-set/main-page/top-example-create-cpp17.mdx"
import TopExampleCreateUntilCpp17 from "./_codes/unordered-set/main-page/top-example-create-until-cpp17.mdx"
import TopExampleCreateFromRange from "./_codes/unordered-set/main-page/top-example-create-from-range.mdx"

import TopExampleInsertOrdinary from "./_codes/unordered-set/main-page/top-example-insert-ordinary.mdx"
import TopExampleInsertInitList from "./_codes/unordered-set/main-page/top-example-insert-many-at-once.mdx"
import TopExampleInsertFromRange from "./_codes/unordered-set/main-page/top-example-insert-from-range.mdx"

import TopExampleSearchFind from "./_codes/unordered-set/main-page/top-example-search-find.mdx"
import TopExampleSearchCount from "./_codes/unordered-set/main-page/top-example-search-count.mdx"
import TopExampleSearchContains from "./_codes/unordered-set/main-page/top-example-search-contains.mdx"

<!-- Advanced Examples -->
import ExampleAdvancedStudents from "./_codes/unordered-set/main-page/example-advanced-students.mdx"

<!-- Deduction Guides -->
import DeductionGuides from "./_codes/unordered-set/main-page/deduction-guides.mdx"

<NotFinished />

# Unordered Set class reference

## Overview

<Tabs>
<TabItem value="simplified" label="Simplified (since C++11)" default>
	<CodeSimplifiedRegular/>
</TabItem>
<TabItem value="detailed" label="Detailed">
	<Tabs>
		<TabItem value="regular" label="Regular (since C++11)" default>
			<CodeDetailedReguler/>
		</TabItem>
		<TabItem value="pmr" label="Polymorphic (since C++17)">
			<CodeDetailedPmr/>
		</TabItem>
	</Tabs> 
</TabItem>
</Tabs>

The `std::unordered_set` is an associative container for storing unique objects.
### Example usage

The examples in this section are very simple ones. Navigate to [examples section at the bottom](#more-examples) for more.


<Tabs>
<TabItem value="create" label="Create" default>
<div style={{ padding: "10px 20px", border: "1px solid gray" }}>
	<SwitchView content={
			{
				"cpp17": <TopExampleCreateCpp17/>,
				"until-cpp17": <TopExampleCreateUntilCpp17/>,
				"From range": <TopExampleCreateFromRange/>
			}
	}/>

:::caution Order of elements
It's important to notice, that although there's an arbitrary order chosen in the examples' comments,
the elements inside remain unordered (as the name of the container suggests), which means we aren't guaranteed
to have any particular order while iterating over the unordered set. 
:::

</div>
</TabItem>

<TabItem value="insert" label="Insert">
<div style={{ padding: "10px 20px", border: "1px solid gray" }}>
	<SwitchView content={
		{
			"Ordinary": <TopExampleInsertOrdinary/>,
			"Many at once": <TopExampleInsertInitList/>,
			"From range": <TopExampleInsertFromRange/>
		}
	}/>
</div>
</TabItem>

<TabItem value="search" label="Search">
<div style={{ padding: "10px 20px", border: "1px solid gray" }}>
	<SwitchView content={
		{
			"Contains (since C++20)": <TopExampleSearchContains/>,
			"Count": <TopExampleSearchCount/>,
			"Find": <TopExampleSearchFind/>
		}
	}/>
</div>
</TabItem>
</Tabs>


### Technical details

<details>
<summary>Technical definition of an unordered_set</summary>
<div>
Unordered set is an associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.

Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.

Container elements may not be modified (even by non const iterators) since modification could change an element's hash and corrupt the container.

std::unordered_set meets the requirements of Container, AllocatorAwareContainer, UnorderedAssociativeContainer.
</div>
</details>

<ClassSummary name="unordered_set" namespaces="std" folder="unordered_set" headerName="unordered_set">

## Template parameters

<SymbolTable noTraits>
	<Symbol name="Key"		desc="The type of the stored values"/>
	<Symbol name="Hash" 		desc={<>A unary callable, that takes an argument of type <code>Key</code>, and returns a unique value</>}/>
	<Symbol name="KeyEqual" 		desc={<>A binary, callable predicate that takes two arguments of type <code>Key</code> and returns a bool</>}/>
	<Symbol name="Allocator" 		desc="A class that manages the allocation and deallocation of memory"/>
</SymbolTable>

## Type names

<SymbolTable>
	<Symbol pub name="key_type"				desc={<><code>Key</code></>}/>
	<Symbol pub name="value_type"			desc={<><code>Key</code></>}/>
	<Symbol pub name="size_type" 			desc={<>Unsigned integer type (usually <code>std::size_t</code>)</>}/>
	<Symbol pub name="difference_type"	desc={<>Signed integer type (usually <code>std::ptrdiff_t</code>)</>}/>
	<Symbol pub name="hasher"				desc={<><code>Hash</code></>}/>
	<Symbol pub name="key_equal" 				desc={<><code>KeyEqual</code></>}/>
	<Symbol pub name="allocator_type"			desc={<><code>Allocator</code></>}/>
	<Symbol pub name="reference"				desc={<code>value_type&</code>}/>
	<Symbol pub name="const_reference"			desc={<code>const value_type&</code>}/>
	<Symbol pub name="pointer"			desc={<code>std::allocator_traits&lt;Allocator&gt;::pointer</code>}/>
	<Symbol pub name="const_pointer"			desc={<code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>}/>
	<Symbol pub name="iterator"			desc={<>Constant <a href="#"><code>LegacyForwardIterator</code></a> to <code>value_type</code></>}/>
	<Symbol pub name="const_iterator"			desc={<> <a href="#"><code>LegacyForwardIterator</code></a> to const value_type </>}/>
	<Symbol pub name="local_iterator"			desc={<>An iterator type whose category, value, difference, pointer and
reference types are the same as <code>iterator</code>. This iterator
can be used to iterate through a single bucket <b>but not across buckets</b></>}/>
	<Symbol pub name="const_local_iterator"			desc={<>An iterator type whose category, value, difference, pointer and
reference types are the same as <code>const_iterator</code>. This iterator
can be used to iterate through a single bucket <b>but not across buckets</b></>}/>
	<Symbol pub name={<>node_type <small>(since C++17)</small></>}			desc="A specialization of node handle representing a container node"/>
<Symbol pub name={<> insert_return_type <small>(since C++17)</small> </>}>
Type describing the result of inserting a `node_type`, a specialization of

```cpp
template <class Iter, class NodeType> struct /*unspecified*/ {
    Iter     position;
    bool     inserted;
    NodeType node;
};
```
instantiated with template arguments `iterator` and `node_type`
</Symbol>
</SymbolTable>

## Iterator invalidation

<SymbolTable noTraits>
	<Symbol name={<center><b>Operation</b></center>}	desc={<center><b>Invalidated</b></center>}/>
	<Symbol name="All read only operations, swap, std::swap"	desc="Never"/>
	<Symbol name="Clear, rehash, reverse, operator="	desc="Always"/>
	<Symbol name="Insert, emplace, emplace_hiny"	desc="Only if causes rehash"/>
	<Symbol name="Erase"	desc="Only to the element erased"/>
</SymbolTable>

## Member functions

<SymbolTable>	
	<Symbol pub autoLink linkName="constructor" name="(constructor)">
		Constructs the <code>unordered_set</code>
	</Symbol>
	<Symbol pub autoLink linkName="destructor" name="(destructor)">
		Destructs the <code>unordered_set</code>
	</Symbol>
	<Symbol pub autoLink linkName="operator=" name="operator=">
		Assigns values to the container
	</Symbol>
	<Symbol pub autoLink linkName="get_allocator" name="get_allocator">
		Returns the associated allocator
	</Symbol>

</SymbolTable>

### Iterators

<SymbolTable>	
	<Symbol pub autoLink linkName="begin" name={<>begin<br/>cbegin</>}>
		Returns an iterator to the beginning
	</Symbol>
	<Symbol pub autoLink linkName="end" name={<>end<br/>cend</>}>
		Returns an iterator to the end
	</Symbol>
</SymbolTable>

### Capacity

<SymbolTable>
	<Symbol pub autoLink linkName="empty" name="empty">
		Checks whether the container is empty
	</Symbol>
	<Symbol pub autoLink linkName="size" name="size">
		Returns the number of elements
	</Symbol>
	<Symbol pub autoLink linkName="max_size" name="max_size">
		Returns the maximum possible number of elements
	</Symbol>
</SymbolTable>

### Modifiers

<SymbolTable>
	<Symbol pub autoLink linkName="clear" name="clear">
		Clears the contents
	</Symbol>
	<Symbol pub autoLink linkName="insert" name="insert">
		Inserts elements or nodes (since c++17)
	</Symbol>
	<Symbol pub autoLink linkName="emplace" name="emplace">
		Constructs element in-place
	</Symbol>
	<Symbol pub autoLink linkName="emplace_hint" name="emplace_hint">
		Constructs elements in-place using a hint (iterator)
	</Symbol>
	<Symbol pub autoLink linkName="erase" name="erase">
		Erases elements
	</Symbol>
	<Symbol pub autoLink linkName="swap" name="swap">
		Swaps the contents
	</Symbol>
	<Symbol pub autoLink linkName="extract" name={<>extract <small>(since c++17)</small></>}>
		Extract nodes from the container
	</Symbol>
	<Symbol pub autoLink linkName="merge" name={<>merge <small>(since c++17)</small></>}>
		Splices nodes from another container
	</Symbol>

</SymbolTable>


### Lookup

<SymbolTable>
	<Symbol pub autoLink linkName="count" name="count">
		Returns the number of elements matching specific key
	</Symbol>
	<Symbol pub autoLink linkName="find" name="find">
		Finds element with specific key
	</Symbol>
	<Symbol pub autoLink linkName="contains" name={<>contains <small>(since C++20)</small></>}>
		Checks if the container contains element with specific key
	</Symbol>
	<Symbol pub autoLink linkName="equal_range" name="equal_range">
		Returns range of elements matching a specific key
	</Symbol>

</SymbolTable>

### Bucket interface

<SymbolTable>
	<Symbol pub autoLink linkName="begin" name={<>begin<br/>cbegin</>}>
		Returns an iterator to the beginning of the specified bucket
	</Symbol>
	<Symbol pub autoLink linkName="end" name={<>end<br/>cend</>}>
		Returns an iterator to the end of the specified bucket
	</Symbol>
	<Symbol pub autoLink linkName="bucket_count" name="bucket_count">
		Returns the number of buckets
	</Symbol>
	<Symbol pub autoLink linkName="max_bucket_count" name="max_bucket_count">
		Returns the maximum number of buckets
	</Symbol>
	<Symbol pub autoLink linkName="bucket_size" name="bucket_size">
		Returns the number of elements in specific bucket
	</Symbol>
	<Symbol pub autoLink linkName="bucket" name="bucket">
		Returns the bucket for specific key
	</Symbol>
</SymbolTable>

### Hash policy

<SymbolTable>
	<Symbol pub autoLink linkName="load_factor" name="load_factor">
		Returns average number of elements per bucket
	</Symbol>
	<Symbol pub autoLink linkName="max_load_factor" name="max_load_factor">
		Manages maximum average number of elements per bucket
	</Symbol>
	<Symbol pub autoLink linkName="rehash" name="rehash">
		Reserves at least the specified number of buckets and regenerates the hash table
	</Symbol>
	<Symbol pub autoLink linkName="reserve" name="reserve">
		Reserves space for at least the specified number of elements and regenerates the hash table
	</Symbol>
</SymbolTable>

### Observers

<SymbolTable>
	<Symbol pub autoLink linkName="hash_function" name="hash_function">
		Returns function to hash the keys
	</Symbol>
	<Symbol pub autoLink linkName="key_eq" name="key_eq">
		Returns the function used to compare keys for equality
	</Symbol>
</SymbolTable>

## Non-member functions

<SymbolTable noTraits>
	<Symbol name={<>
				operator==<br/>
				operator!= <small>(removed in C++20)</small><br/>
			</>}
			desc="Compares the values in the unordered_map">
	</Symbol>
	<Symbol pub autoLink linkName="std::swap" name={<>std::swap<small>(std::unordered_set)</small></>}>
		Specializes the <code>std::swap</code> algorithm
	</Symbol>
	<Symbol pub autoLink linkName="erase_if" name={<>std::erase_if<small>(std::unordered_set) (C++20)</small></>}>
		Erases all elements satisfying specific criteria
	</Symbol>
</SymbolTable>
</ClassSummary>

## Deduction guides
<details>
<summary>Click to expand</summary>
<div>
	<DeductionGuides/>
</div>
</details>

## More examples

### Creating a custom hash and comparator.

<div>
	<ExampleAdvancedStudents/>
</div>
<div>

```plaintext title="Result"
Student: Jacob Jones, 19 years old.
Student: Philip Smith, 19 years old.
Student: Philip Davies, 17 years old.
```
</div>

:::note Custom hashes
Note that although we've added four students into the set, we only see information about three of them being displayed.
This is because there are two students with exactly the same data. When the hashes of both of them are being compared, they turn out to be the same,
which then leads to a comparision of the two objects themselves (using `operator==`, hence the it's presence inside `student`). If the comparision tests positive,
the new object (that compared the same as the one already inserted) is not being added.
:::