```cpp
// (1)
template<class InputIt,
         class Hash = std::hash<typename std::iterator_traits<InputIt>::value_type>,
         class Pred = std::equal_to<typename std::iterator_traits<InputIt>::value_type>,
         class Alloc = std::allocator<typename std::iterator_traits<InputIt>::value_type>>
unordered_set(InputIt, InputIt,
         typename /*see below*/::size_type = /*see below*/,
         Hash = Hash(), Pred = Pred(), Alloc = Alloc())
  -> unordered_set<typename std::iterator_traits<InputIt>::value_type, Hash, Pred, Alloc>;
```

```cpp
// (2)
template<class InputIt, class Alloc>
unordered_set(InputIt, InputIt, typename /*see below*/::size_type, Alloc)
  -> unordered_set<typename std::iterator_traits<InputIt>::value_type,
              std::hash<typename std::iterator_traits<InputIt>::value_type>,
              std::equal_to<typename std::iterator_traits<InputIt>::value_type>,
              Alloc>;
```

```cpp
// (3)
template<class InputIt, class Hash, class Alloc>
unordered_set(InputIt, InputIt, typename /*see below*/::size_type, Hash, Alloc)
  -> unordered_set<typename std::iterator_traits<InputIt>::value_type, Hash,
             std::equal_to<typename std::iterator_traits<InputIt>::value_type>, Allocator>;
```

```cpp
// (4)
template<class T, class Allocator>
unordered_set(std::initializer_list<T>, typename /*see below*/::size_type, Allocator)
  -> unordered_set<T, std::hash<T>, std::equal_to<T>, Alloc>;
```

```cpp
// (5)
template<class T, class Hash, class Alloc>
unordered_set(std::initializer_list<T>, typename /*see below*/::size_type, Hash, Alloc)
  -> unordered_set<T, Hash, std::equal_to<T>, Alloc>;
```

```cpp
// (6)
template<class T,
         class Hash = std::hash<T>,
         class Pred = std::equal_to<T>,
         class Alloc = std::allocator<T>>
unordered_set(std::initializer_list<T>,
         typename /*see below*/::size_type = /*see below*/,
         Hash = Hash(), Pred = Pred(), Alloc = Alloc())
  -> unordered_set<T, Hash, Pred, Alloc>;
```
These deduction guides are provided for `unordered_set` to allow deduction from an iterator range (1, 2, 3) or an `std::initializer_list` (4, 5, 6).
The `size_type` parameter type is based on whatever the deduction guided deducted (although both libstdc++ and libc++ just use `std::unordered_set<int>::size_type`).


A deduction guide for an unordered associative container shall not participate in overload resolution if any of the following are true:
 - It has an `InputIterator` template parameter and a type that does not qualify as an input iterator is deduced for that parameter.
 - It has an `Allocator` template parameter and a type that does not qualify as an allocator is deduced for that parameter.
 - It has a `Hash` template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.
 - It has a `Pred` template parameter and a type that qualifies as an allocator is deduced for that parameter.